create schema if not exists "supacontent";

create type "supacontent"."schema_type" as enum ('single', 'collection');

create type "supacontent"."supacontent.schema_type" as enum ('single', 'double');

create table "supacontent"."authors" (
    "id" uuid not null default gen_random_uuid(),
    "sc_user_id" uuid,
    "user_id" uuid,
    "pseudonym" text,
    "first_name" text,
    "last_name" text,
    "description" text,
    "metadata" jsonb,
    "title" text
);


alter table "supacontent"."authors" enable row level security;

create table "supacontent"."content_authors" (
    "id" bigint generated by default as identity not null,
    "author_id" uuid not null,
    "content_id" uuid not null
);


alter table "supacontent"."content_authors" enable row level security;

create table "supacontent"."contents" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "deleted_at" timestamp with time zone,
    "schema_id" uuid default gen_random_uuid()
);


alter table "supacontent"."contents" enable row level security;

create table "supacontent"."schemas" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "deleted_at" timestamp with time zone,
    "archived_at" timestamp with time zone,
    "fields" jsonb,
    "type" text not null
);


alter table "supacontent"."schemas" enable row level security;

CREATE UNIQUE INDEX authors_pkey ON supacontent.authors USING btree (id);

CREATE UNIQUE INDEX content_authors_pkey ON supacontent.content_authors USING btree (id);

CREATE UNIQUE INDEX content_items_pkey ON supacontent.contents USING btree (id);

CREATE UNIQUE INDEX schemas_pkey ON supacontent.schemas USING btree (id);

alter table "supacontent"."authors" add constraint "authors_pkey" PRIMARY KEY using index "authors_pkey";

alter table "supacontent"."content_authors" add constraint "content_authors_pkey" PRIMARY KEY using index "content_authors_pkey";

alter table "supacontent"."contents" add constraint "content_items_pkey" PRIMARY KEY using index "content_items_pkey";

alter table "supacontent"."schemas" add constraint "schemas_pkey" PRIMARY KEY using index "schemas_pkey";

alter table "supacontent"."authors" add constraint "authors_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "supacontent"."authors" validate constraint "authors_user_id_fkey";

alter table "supacontent"."content_authors" add constraint "content_authors_author_id_fkey" FOREIGN KEY (author_id) REFERENCES supacontent.authors(id) ON DELETE CASCADE not valid;

alter table "supacontent"."content_authors" validate constraint "content_authors_author_id_fkey";

alter table "supacontent"."content_authors" add constraint "content_authors_content_id_fkey" FOREIGN KEY (content_id) REFERENCES supacontent.contents(id) ON DELETE CASCADE not valid;

alter table "supacontent"."content_authors" validate constraint "content_authors_content_id_fkey";

alter table "supacontent"."contents" add constraint "contents_schema_id_fkey" FOREIGN KEY (schema_id) REFERENCES supacontent.schemas(id) ON DELETE RESTRICT not valid;

alter table "supacontent"."contents" validate constraint "contents_schema_id_fkey";

alter table "supacontent"."schemas" add constraint "schemas_fields_check" CHECK ((jsonb_typeof(fields) = 'array'::text)) not valid;

alter table "supacontent"."schemas" validate constraint "schemas_fields_check";

alter table "supacontent"."schemas" add constraint "schemas_type_check" CHECK ((type = ANY (ARRAY['single'::text, 'collection'::text]))) not valid;

alter table "supacontent"."schemas" validate constraint "schemas_type_check";



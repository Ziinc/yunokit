create table "public"."supabase_connections" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "refresh_token" text,
    "access_token" text,
    "expires_at" numeric
);


alter table "public"."supabase_connections" enable row level security;

create table "public"."user_data" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "default_workspace_id" bigint,
    "code_verifier" text,
    "user_id" uuid not null
);


alter table "public"."user_data" enable row level security;

create table "public"."workspace_users" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "workspace_id" bigint not null
);


alter table "public"."workspace_users" enable row level security;

create table "public"."workspaces" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "name" text not null,
    "description" text,
    "project_ref" text,
    "api_key" text
);


alter table "public"."workspaces" enable row level security;

CREATE UNIQUE INDEX connections_pkey ON public.supabase_connections USING btree (id);

CREATE UNIQUE INDEX supabase_connections_user_id_key ON public.supabase_connections USING btree (user_id);

CREATE UNIQUE INDEX user_data_user_id_key ON public.user_data USING btree (user_id);

CREATE UNIQUE INDEX user_preferences_pkey ON public.user_data USING btree (id);

CREATE UNIQUE INDEX workspace_users_pkey ON public.workspace_users USING btree (id);

CREATE UNIQUE INDEX workspaces_pkey ON public.workspaces USING btree (id);

alter table "public"."supabase_connections" add constraint "connections_pkey" PRIMARY KEY using index "connections_pkey";

alter table "public"."user_data" add constraint "user_preferences_pkey" PRIMARY KEY using index "user_preferences_pkey";

alter table "public"."workspace_users" add constraint "workspace_users_pkey" PRIMARY KEY using index "workspace_users_pkey";

alter table "public"."workspaces" add constraint "workspaces_pkey" PRIMARY KEY using index "workspaces_pkey";

alter table "public"."supabase_connections" add constraint "connections_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."supabase_connections" validate constraint "connections_user_id_fkey";

alter table "public"."supabase_connections" add constraint "supabase_connections_user_id_key" UNIQUE using index "supabase_connections_user_id_key";

alter table "public"."user_data" add constraint "user_data_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_data" validate constraint "user_data_user_id_fkey";

alter table "public"."user_data" add constraint "user_data_user_id_key" UNIQUE using index "user_data_user_id_key";

alter table "public"."user_data" add constraint "user_preferences_default_workspace_id_fkey" FOREIGN KEY (default_workspace_id) REFERENCES workspaces(id) ON DELETE SET NULL not valid;

alter table "public"."user_data" validate constraint "user_preferences_default_workspace_id_fkey";

alter table "public"."workspace_users" add constraint "workspace_users_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."workspace_users" validate constraint "workspace_users_user_id_fkey";

alter table "public"."workspace_users" add constraint "workspace_users_workspace_id_fkey" FOREIGN KEY (workspace_id) REFERENCES workspaces(id) ON DELETE CASCADE not valid;

alter table "public"."workspace_users" validate constraint "workspace_users_workspace_id_fkey";

alter table "public"."workspaces" add constraint "workspaces_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."workspaces" validate constraint "workspaces_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_supabase_connection()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  connection_record record;
  api_response json;
  http_status integer;
begin
  -- Get the most recent connection for the current user
  select * from public.supabase_connections 
  where user_id = auth.uid() 
  order by created_at desc 
  limit 1 
  into connection_record;

  -- Check if we have a connection
  if connection_record is null then
    return json_build_object(
      'result', false,
      'error', 'No Supabase connection found'
    );
  end if;

  -- Check if token is expired
  if connection_record.expires_at < extract(epoch from now()) then
    return json_build_object(
      'result', false,
      'error', 'Token expired'
    );
  end if;

  return json_build_object(
      'result', true,
      'error', null
  );

exception when others then
  return json_build_object(
    'result', false,
    'error', SQLERRM
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.check_token_needs_refresh()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  connection_record record;
  token_refresh_threshold numeric := 300000; -- 5 minutes in seconds
begin
  -- Get the most recent connection for the current user
  select * from public.supabase_connections 
  where user_id = auth.uid() 
  limit 1 
  into connection_record;

  -- If no connection, it doesn't need refreshing (there's nothing to refresh)
  if connection_record is null then
    return false;
  end if;

  -- Check if token is expired or about to expire (within 5 minutes)
  if connection_record.expires_at is null or 
     connection_record.expires_at > (extract(epoch from now()) - token_refresh_threshold) then
    return true;
  end if;

  -- Token is still valid and not close to expiration
  return false;

exception when others then
  -- On any error, return false as we can't determine if refresh is needed
  return false;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_supabase_connection()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- Delete the supabase_connection record for the current authenticated user
  delete from public.supabase_connections 
  where user_id = auth.uid();
  
  -- The function will complete successfully even if no rows were deleted
  -- This prevents information leakage about whether a connection existed
end;
$function$
;

CREATE OR REPLACE FUNCTION public.sb_mgmt_api(endpoint text, method text DEFAULT 'GET'::text, body json DEFAULT NULL::json, base_url text DEFAULT 'https://api.supabase.com/v1'::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$declare
  connection_record record;
  api_response json;
  http_status integer;
  full_url text;
begin
  -- Ensure endpoint starts with /
  endpoint := case 
    when left(endpoint, 1) = '/' then endpoint 
    else '/' || endpoint 
  end;
  
  full_url := rtrim(base_url, '/') || endpoint;

  -- Get valid connection for the current user
  select * from public.supabase_connections 
  where user_id = auth.uid() 
    and expires_at >= extract(epoch from now())
  order by created_at desc 
  limit 1 
  into connection_record;

  -- Check if we have a valid connection
  if connection_record is null then
    raise exception 'No valid Supabase connection found';
  end if;

  -- Make request to Supabase Management API
  select 
    status,
    content::json
  from http((
    method,
    full_url,
    ARRAY[
      http_header('Authorization', 'Bearer ' || connection_record.access_token),
      http_header('Content-Type', 'application/json')
    ],
    case when body is not null then body::text else null end,
    null
  )::http_request)
  into http_status, api_response;

  -- Raise exception for non-2xx responses
  if http_status < 200 or http_status >= 300 then
    raise exception 'API request failed with status %: %', http_status, api_response;
  end if;

  return json_build_object('result', api_response);

exception when others then
  return json_build_object('error', SQLERRM);
end;$function$
;

grant delete on table "public"."supabase_connections" to "anon";

grant insert on table "public"."supabase_connections" to "anon";

grant references on table "public"."supabase_connections" to "anon";

grant select on table "public"."supabase_connections" to "anon";

grant trigger on table "public"."supabase_connections" to "anon";

grant truncate on table "public"."supabase_connections" to "anon";

grant update on table "public"."supabase_connections" to "anon";

grant delete on table "public"."supabase_connections" to "authenticated";

grant insert on table "public"."supabase_connections" to "authenticated";

grant references on table "public"."supabase_connections" to "authenticated";

grant select on table "public"."supabase_connections" to "authenticated";

grant trigger on table "public"."supabase_connections" to "authenticated";

grant truncate on table "public"."supabase_connections" to "authenticated";

grant update on table "public"."supabase_connections" to "authenticated";

grant delete on table "public"."supabase_connections" to "service_role";

grant insert on table "public"."supabase_connections" to "service_role";

grant references on table "public"."supabase_connections" to "service_role";

grant select on table "public"."supabase_connections" to "service_role";

grant trigger on table "public"."supabase_connections" to "service_role";

grant truncate on table "public"."supabase_connections" to "service_role";

grant update on table "public"."supabase_connections" to "service_role";

grant delete on table "public"."user_data" to "anon";

grant insert on table "public"."user_data" to "anon";

grant references on table "public"."user_data" to "anon";

grant select on table "public"."user_data" to "anon";

grant trigger on table "public"."user_data" to "anon";

grant truncate on table "public"."user_data" to "anon";

grant update on table "public"."user_data" to "anon";

grant delete on table "public"."user_data" to "authenticated";

grant insert on table "public"."user_data" to "authenticated";

grant references on table "public"."user_data" to "authenticated";

grant select on table "public"."user_data" to "authenticated";

grant trigger on table "public"."user_data" to "authenticated";

grant truncate on table "public"."user_data" to "authenticated";

grant update on table "public"."user_data" to "authenticated";

grant delete on table "public"."user_data" to "service_role";

grant insert on table "public"."user_data" to "service_role";

grant references on table "public"."user_data" to "service_role";

grant select on table "public"."user_data" to "service_role";

grant trigger on table "public"."user_data" to "service_role";

grant truncate on table "public"."user_data" to "service_role";

grant update on table "public"."user_data" to "service_role";

grant delete on table "public"."workspace_users" to "anon";

grant insert on table "public"."workspace_users" to "anon";

grant references on table "public"."workspace_users" to "anon";

grant select on table "public"."workspace_users" to "anon";

grant trigger on table "public"."workspace_users" to "anon";

grant truncate on table "public"."workspace_users" to "anon";

grant update on table "public"."workspace_users" to "anon";

grant delete on table "public"."workspace_users" to "authenticated";

grant insert on table "public"."workspace_users" to "authenticated";

grant references on table "public"."workspace_users" to "authenticated";

grant select on table "public"."workspace_users" to "authenticated";

grant trigger on table "public"."workspace_users" to "authenticated";

grant truncate on table "public"."workspace_users" to "authenticated";

grant update on table "public"."workspace_users" to "authenticated";

grant delete on table "public"."workspace_users" to "service_role";

grant insert on table "public"."workspace_users" to "service_role";

grant references on table "public"."workspace_users" to "service_role";

grant select on table "public"."workspace_users" to "service_role";

grant trigger on table "public"."workspace_users" to "service_role";

grant truncate on table "public"."workspace_users" to "service_role";

grant update on table "public"."workspace_users" to "service_role";

grant delete on table "public"."workspaces" to "anon";

grant insert on table "public"."workspaces" to "anon";

grant references on table "public"."workspaces" to "anon";

grant select on table "public"."workspaces" to "anon";

grant trigger on table "public"."workspaces" to "anon";

grant truncate on table "public"."workspaces" to "anon";

grant update on table "public"."workspaces" to "anon";

grant delete on table "public"."workspaces" to "authenticated";

grant insert on table "public"."workspaces" to "authenticated";

grant references on table "public"."workspaces" to "authenticated";

grant select on table "public"."workspaces" to "authenticated";

grant trigger on table "public"."workspaces" to "authenticated";

grant truncate on table "public"."workspaces" to "authenticated";

grant update on table "public"."workspaces" to "authenticated";

grant delete on table "public"."workspaces" to "service_role";

grant insert on table "public"."workspaces" to "service_role";

grant references on table "public"."workspaces" to "service_role";

grant select on table "public"."workspaces" to "service_role";

grant trigger on table "public"."workspaces" to "service_role";

grant truncate on table "public"."workspaces" to "service_role";

grant update on table "public"."workspaces" to "service_role";

create policy "Enable insert for users based on user_id"
on "public"."user_data"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable users to update their own data only"
on "public"."user_data"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable users to view their own data only"
on "public"."user_data"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable delete for users based on user_id"
on "public"."workspaces"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable insert for authenticated users only"
on "public"."workspaces"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable update for users based on user id"
on "public"."workspaces"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "select own and invited"
on "public"."workspaces"
as permissive
for select
to authenticated
using (((id IN ( SELECT wu.id
   FROM workspace_users wu
  WHERE ((wu.user_id = ( SELECT auth.uid() AS uid)) AND (wu.id = wu.id)))) OR (( SELECT auth.uid() AS uid) = user_id)));



create extension if not exists "http" with schema "extensions";


